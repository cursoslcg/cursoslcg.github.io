<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Python II y GitHub</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Python II y GitHub
]
.institute[
### Licenciatura en Ciencias Genómicas,UNAM
]
.date[
### First version: yyy-mm-dd; Last update: 2024-04-03
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;

## Objetivo

Lograr hacer programas CLI usando la libreria argparser de python.

---

## Introducción a argparse y CLI

- Un **programa de línea de comandos** (CLI) es un tipo de programa que se opera introduciendo **comandos a través de un terminal**, en lugar de utilizar una interfaz gráfica de usuario (GUI).  

- Los programas de CLI son comunes en la programación y la administración de sistemas debido a su robustez, simplicidad y **facilidad de automatización**.  

- En Python, podemos crear programas de CLI utilizando el **módulo argparse**, que facilita el **análisis de los argumentos y las opciones** de la línea de comandos.  

- `argparse` es un módulo de la biblioteca estándar de Python para la creación de interfaces de línea de comandos. Los **argumentos son las entradas** que los **usuarios pasan a los programas** cuando los ejecutan desde el terminal.  

- Con argparse, podemos especificar los tipos de argumentos que esperamos, mostrar mensajes de ayuda y mucho más.

---
## Ejemplos de programas CLI en bioinformática

Los programas de línea de comandos (CLI) son esenciales en bioinformática debido a su eficiencia, flexibilidad y facilidad de automatización. Aquí hay algunos ejemplos:

-  **BLAST (Basic Local Alignment Search Tool)**
   
   BLAST permite alinear secuencias de consulta con bases de datos de secuencias para buscar coincidencias.


```bash
   blastp -query protein.fa -db nr -out results.txt
```

-  **SAMtools**

SAMtools es una serie de programas para interactuar con archivos de alineación de secuencias en los formatos SAM y BAM.



```bash
   samtools view -bS aln.sam &gt; aln.bam
```

---

-  **BEDTools**

BEDTools es una serie de herramientas para manipular y analizar archivos BED (Browser Extensible Data), que se utilizan para almacenar datos genómicos.


```bash
   bedtools intersect -a fileA.bed -b fileB.bed &gt; overlaps.bed
```

-  **Bowtie2**

Bowtie2 es una herramienta para alinear secuencias de lecturas de secuenciación con genomas de referencia.


```bash
   bowtie2 -x reference -U reads.fq -S alignment.sam
```

---
#  Programas CLI en bioinformática

.content-box-yellow[
En cada uno de estos casos, argparse (o un módulo similar en otro lenguaje de programación) podría ser utilizado para procesar los argumentos de línea de comandos.

Estos ejemplos ilustran cómo los programas CLI son fundamentales en bioinformática, y resaltan la importancia de aprender a usar herramientas como argparse para crear tus propios programas CLI.
]

---

## Uso más simple de argparse

Programa que acepta un número entero desde la línea de comandos y luego imprime el cuadrado de ese número.


```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("x", type=int, help="El número entero a elevar al cuadrado")
args = parser.parse_args()
print(args.x ** 2)
```


Guarda esto como **square.py**. Ejecútalo desde la línea de comandos así:


```bash
python square.py 5

# qué pasa aqui?
python square.py -h

# que pasa aqui ..
python square.py 
```


---

# Entendiendo argparse

1. `parser = argparse.ArgumentParser()`: Esto crea un objeto que se encarga de "analizar" (parsear) la línea de comandos.

2. `parser.add_argument("x", type=int, help="El número base")`: Esto le dice al analizador que espere un argumento posicional llamado "x". El `type=int` significa que este argumento debe ser un número entero, y el `hel`p es el mensaje de ayuda que se muestra si pides ayuda desde la línea de comandos utilizando el comando del script seguido por -h o --help.

3. `args = parser.parse_args()`: Analiza la línea de comandos y asocia los argumentos ingresados al nombre correspondiente.

4. `print(args.x ** 2)`: Por último, toma el número introducido, lo eleva al cuadrado (eso es lo que hace ** 2) e imprime el resultado.

---
## Argumentos opcionales 

Los argumentos opcionales están precedidos por - o --.



```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--x", type=int, default=2, help="El número base")
args = parser.parse_args()
print(args.x ** 2)
```

Guarda esto como **square2.py**. Ejecútalo desde la línea de comandos así:


```bash
python square2.py --x 5

# que pasa aqui?
python square2.py
```

---
## Argumentos posicionales vs opcionales

- Los **argumentos posicionales** se identifican por su posición en la línea de comandos. Son requeridos y deben ingresar en el orden correcto.

- Los **argumentos opcionales** se identifican por el nombre y pueden ingresarse en cualquier orden. Casi siempre están precedidos por - o --, y pueden tener valores predeterminados.


Los argumentos posicionales y opcionales son fundamentales en argparse y es importante entender la diferencia entre los dos. 

---
# Cómo decidir entre arg posicional vs opcional ?

.content-box-green[

Si un argumento es esencial para que tu programa funcione correctamente, debería ser un argumento posicional. 

Por otro lado, los argumentos opcionales (aquellos precedidos por - o --) son útiles cuando deseas proporcionar una funcionalidad adicional a tu programa que no es estrictamente necesaria para que funcione. También son útiles cuando existe un valor predeterminado, pero quieres dar a los usuarios la opción de cambiarlo.

]


---
## Manejando  un argumento con más de un valor

¿Qué pasa si quiero pasar mas de un valor a un argumento?

Programa que suma los números que se le pasan por línea de comando.


```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("x", type=int, nargs="+")
args = parser.parse_args()
print(sum(args.x))
```

en línea de comando:


```bash
python suma.py 1 2 3 4 5
```

.content-box-yellow[
Esto pasa los números 1, 2, 3, 4 y 5 como argumento al script. Como usaste **nargs="+"** en la **definición del argumento**, cualquier número de argumentos (pero al menos uno) será aceptado.
]

---
## Manejando  mas de un argumento

Programa que recibe el nombre del archivo a procesar y el nombre del archivo de salida donde se guardaran los resultados.


```python
import argparse

parser = argparse.ArgumentParser(description="Lee archivo de entrada y salida")

# Agrega un argumento posicional para el archivo de entrada. 
parser.add_argument("input_file", type=str, help="El archivo de texto que quieres procesar.")

# Agrega un argumento opcional para el archivo de salida.
# 'out.txt' como nombre de archivo por defecto.
parser.add_argument("--output", type=str, default="out.txt",
                    help="El archivo donde se guarda la salida. 'out.txt' por defecto.")
args = parser.parse_args()

print("Archivo de entrada: ", args.input_file)
print("Archivo de salida: ", args.output)
```

Salvalo como readfile.py y correlo 2 veces con los siguientes argumentos:


```bash
python readfile.py my_input.txt

python readfile.py my_input.txt --output my_output.txt
```

---
# Mas de un argumento y + de un nombre
Es común en las herramientas de línea de comandos ofrecer una versión corta y rápida de los argumentos más comunes.

Pasamos nuestro argumento posicional a un opcional pero obligatorio, para dar la opción al usuario de usar una versión corta o larga del argumento.


```python
import argparse

parser = argparse.ArgumentParser(description="Lee archivo de entrada y salida")

# Agrega un argumento posicional para el archivo de entrada. 
parser.add_argument("-i", "--input_file", type=str, required=True, 
                    help="El archivo de texto que quieres procesar.")
                    
# Agrega un argumento opcional para el archivo de salida.
# 'out.txt' como nombre de archivo por defecto.
parser.add_argument("-o", "--output", type=str, default="out.txt",
                    help="El archivo donde se guarda la salida. 'out.txt' por defecto.")

# Parsea la línea de comandos
args = parser.parse_args()

print("Archivo de entrada: ", args.input_file)
print("Archivo de salida: ", args.output)
```

---

# Mas de un argumento y + de un nombre

ejecutalo como :


```bash
python readfile.py -i example.txt
python readfile.py --input_file example.txt --output myoutput.txt 
```

.content-box-yellow[
**Importante**: dentro del programa deberas utilizar args.file y no args.f, porque en  python el nombre de la propiedad es la versión del nombre del argumento con caracteres alfanuméricos más largos, eliminando los signos - o --. OBviamente si solo defines -f, usarás args.f
]

---
# Ejercicio / Tarea

A. El programa de count_atgc.py pasa como argumento el nombre del archivo de entrada.

B. Modifica el programa para que permita pasar como argumento las letras de las que quieres ver su frecuencia.

```
count_atgc.py dna.seq -n A T
count_atgc.py dna.seq -nucleotides A T
```

C. Testea tus casos de prueba o escenarios. Si no creaste tu documento de pruebas es el momento que lo hagas y pruebes tu programa.

D. Genera el manual o README para usar tu programa.

Recuerda que en cada punto, debes mandar los cambios a github.

Se evaluará el proceso que vas haciendo de cada punto y los commits que al menos hagas en cada punto. También, el paso de argumentos deberá estar includo en la versión final.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
