<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Software Cientifico y la IS</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Software Cientifico y la IS
]
.institute[
### Licenciatura en Ciencias Genómicas,UNAM
]
.date[
### First version: yyy-mm-dd; Last update: 2023-03-09
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;



# Contenido

1. Introducción ( El problema )

2. FAIR

3. Ingeniería de Software

4. subconjunto mínimo de principios comunesde IS


---

# Introducción


.pull-left[
&lt;img src="https://www.software.ac.uk/sites/default/files/images/content/ResearchSoftwareSurveyWordle27Nov14%20copy.png" width="100%" style="display: block; margin: auto;" /&gt;
]

.pull-right[

- Muchos resultados en la literatura científica ahora dependen del software. 

- Las hipótesis se construyen a partir de los resultados de modelos computacionales. 

- Los datos se recopilan y analizan mediante paquetes comerciales, módulos de código abierto y scripts personalizados. 
- El software es fundamental para la accesibilidad y reutilización de los datos científicos y la verificación de los métodos científicos. 

]

.tiny[
[Graham Lee, et al. Barely sufficient practices in scientific computing](https://www.cell.com/patterns/pdf/S2666-3899\(21\)00016-7.pdf)]

---

# Encuesta 

De los científicos encuestados por Pinto et al. en 2018

- el **86 % ** informa que desarrollar software científico es importante para su propia investigación y 

--

- el **63 %** que es importante para la investigación de otros. 

--

- El encuestado promedio informó que dedicaba el **30 % ** de su tiempo de trabajo a escribir software científico.

--

- El diseño y la construcción de software de investigación sigue siendo en gran medida una industria artesanal.

- El **99%** de los encuestados dijeron que el autoaprendizaje era importante para la adquisición de habilidades de desarrollo de software. 


.tiny[
[Pinto et al. How do scientists develop scientific software? An external replication](https://ieeexplore.ieee.org/document/8330263)]



---

# Encuesta 

Lejos de ponerse de acuerdo sobre las mejores prácticas en toda la investigación computaciona, tienen **prácticas de software divergentes** que conducen a **diferentes niveles** de **confiabilidad**, replicabilidad y reutilización del software de investigación. 


.tiny[
[Graham Lee, et al. Barely sufficient practices in scientific computing](https://www.cell.com/patterns/pdf/S2666-3899\(21\)00016-7.pdf)]

---

# ¿ Cuál es el problema del software de investigación ?


El software escrito **sin la debida atención a las prácticas de ingeniería** relevantes puede sufrir muchos problemas.

Dos casos presentados sobre la enfermedad por coronavirus 2019 (COVID-19) :

- The Lancet publicó, y luego se retractó, un análisis de los efectos del tratamiento con hidroxicloroquina o cloroquina para el COVID-19. 

- Se utilizó un modelo de propagación de la pandemia producido en el Imperial College de Londres para justificar las políticas gubernamentales relacionadas con el confinamiento en marzo de 2020.

---

# Caso Lancet

.content-box-blue[

¿ Qué habian publicado inicialmente?

¿ Qué fué lo que corrigieron ?

¿ Dónde estuvo el problema ?

¿ Qué aprendemos ?


.tiny[
[Two Huge Covid-19 Studies Are Retracted After Scientists Sound Alarms](https://www.nytimes.com/2020/06/04/health/coronavirus-hydroxychloroquine.html)]

]

Pon tus comentarios [aqui](https://etherpad.wikimedia.org/p/LCG-PythonI)

---

# Caso Imperial College de Londres

.content-box-blue[

¿ Qué habian publicado inicialmente?

¿ Qué fué lo que corrigieron ?

¿ Dónde estuvo el problema ?

¿ Qué aprendemos ?

.tiny[
[INFLUENTIAL PANDEMIC SIMULATION VERIFIED BY CODE CHECKERS](https://media.nature.com/original/magazine-assets/d41586-020-01685-y/d41586-020-01685-y.pdf)]

]

Pon tus comentarios [aqui](https://etherpad.wikimedia.org/p/LCG-PythonI)

---

# Caso Lancet: Lo que aprendemos


- En la retractación, el profesor Mehra indica que **los datos y el software** en los que se basó el análisis **no estaban disponibles para la revisión o replicación por pares independientes**.

- "Ahora me queda claro que con la esperanza de contribuir a esta investigación durante un momento de gran necesidad, no hice lo suficiente para **garantizar que la fuente de datos fuera adecuada para este uso**", dijo el Dr. Mandeep Mehra

- "La ubicuidad de los "grandes datos" puede ser tentadora para los investigadores, agregó, pero aún **deben comprender de dónde provienen los datos, su autenticidad y calidad.**"

.tiny[
[Two Huge Covid-19 Studies Are Retracted After Scientists Sound Alarms](https://www.nytimes.com/2020/06/04/health/coronavirus-hydroxychloroquine.html)]


---

# Caso Imperial College de Londres

- Inicialmente el modelo no estaba disponible para el escrutinio externo y la replicación, lo hicieron 3 meses después de su publicación, por presiones.

- La confianza pública en el modelo ya se había erosionado, una situación que podría haberse evitado **documentando** y **probando** el software cuando se utilizó por primera vez.

- "El código del estudio se veía **"horrible"**, pero que tales deficiencias se esperan en el código escrito por científicos que no son **especialistas en desarrollo de software**." El autor dijo "Cleaning up and releasing the code was not a top priority at the time."


.tiny[
[INFLUENTIAL PANDEMIC SIMULATION VERIFIED BY CODE CHECKERS](https://media.nature.com/original/magazine-assets/d41586-020-01685-y/d41586-020-01685-y.pdf)]

]

---

# ¿Qué es la Ingeniería de Software ?


La **Ingeniería de Software** (IS) es una de las ramas de las ciencias de la computación que estudia la creación de **software confiable y de calidad**, basándose en métodos y técnicas de ingeniería, y brindando soporte operacional y de mantenimiento. 

La ingeniería de software requiere llevar a cabo numerosas tareas agrupadas en etapas, al conjunto de estas etapas se le denomina **ciclo de vida**. 



.tiny[
[Wikipedia: Ing. de Software](https://es.wikipedia.org/wiki/Ingenier%C3%ADa_de_software)]



---

# ¿Qué es la Ingeniería de Software ?

Los nombres de las etapas son identificadas como Requisitos, Análisis, Diseño, Codificación y Pruebas, como lo ilustra la siguiente figura. 


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://agenciadigitalamd.com/wp-content/webp-express/webp-images/uploads/2021/04/ciclos-de-desarrollo-de-software-800x793-1-768x761.jpg.webp" alt="Ciclo de desarrollo de Software" width="60%" /&gt;
&lt;p class="caption"&gt;Ciclo de desarrollo de Software&lt;/p&gt;
&lt;/div&gt;

---

# ¿Qué es la IS ? : Requisitos

En esta etapa hay que identificar el **qué** se necesita, qué se requiere que haga el programa, cúal es el problema a abordar, qué pretendo solucionar.

*Req. Funcionales* 

Describen lo que el sistema debe hacer: flujo de trabajo, entradas, salidas, excepciones.

*Reg. No funcionales*

Se refieren a las  propiedades del sistema como tiempo de respuesta, capacidad de almacenamiento, seguridad, o alguna especificación como el lenguaje de programación,  plataforma tecnológica, estándares de calidad (MoProSoft).


Técnicas para obtener los requisitos:

- Entrevistas
- Cuestionarios
- Observación

**Entregables**: Documento con la lista de requisitos descritos, puede incluir diagramas de casos de uso.

---

# ¿Qué es la IS ? : Requisitos - ejemplo

**Queremos un programa que me permita sumar números.**

¿fácil? 

--
 
¿ya quieres programarlo? pero ...

--

¿cuáles son los requisitos? 

--

- ¿Serán sumas de base 10 ? es decir no binarios, no octales, ni hexadecimales.

--

- ¿Sólo enteros o también flotantes ?

--

- ¿Cuántos números serán?

--

- ¿Los datos se pasarán en un archivo o se pedirán por teclado ?

--

- ¿Cómo debe presentarse el resultado ? ¿quieres algún mensaje?


---

## Levantemos los Requisitos

**Queremos un programa que me permita sumar números.**

--

- Programa que sume números base 10, enteros como flotantes.

--

- El programa debe ser capaz de recibir n números a sumar en un archivo, uno por línea. Debe mandar un mensaje de error si el archivo no existe.

--

- El programa no debe hacer la suma, y debe mandar un error cuando se introduzcan valores no válidos.
  
--

- El resultado deberá ser:

   n1 + n2 + n3 + n4 = suma
   
   donde n1..nn son los números introducidos por el usuario.

--

- **Casos de prueba**:  A+B  "Error, no se pueden sumar letras", 10 + 5 = 15, 5.6 + 2.4 = 8.0 


---

## Análisis y diseño

Consiste en:

- Estudiar y entender los requisitos para proponer una solución a implementarse
- Buscar la mejor solución al problema
- Identificar toda la información de entrada y salida del sistema
- Definir restricciones en los datos
- Definir cómo se visualizarán los datos
- Etcétera

---

## Análisis y diseño: Herramientas y Técnicas

.pull-left[
- Modelado   (UML)  Tool: [LucidChart](https://www.lucidchart.com/pages/)
    - Diagramas de comportamiento: 
        - Use Case Diagram (used by some methodologies during requirements gathering)
        - Activity Diagram
        - State Machine Diagram
    - Diagramas de interacción:
        - Sequence Diagram
        - Communication Diagram
        - Timing Diagram
        - Interaction Overview Diagram
- Bosquejos/Prototipos visuales (mockups)

Entregables: Documento de AD.
]

.pull-right[

&lt;img src="img/casosuso.png" width="800px" style="display: block; margin: auto;" /&gt;

]


---

## Codificación

Traducir el diseño en un lenguaje de programación y tecnología específicos.

Seleccionar:

* Lenguajes de programación
* Paradigma de programación
* Estándares de programación
* Infraestructura de desarrollo
* Interfaces de desarrollo integrado (IDEs)
* Software de base de datos

Estándares de programación

* Mejoran legibilidad del código y su mantenimiento
* Nombres de variables, clases, scripts, etcétera
* Documentación interna del código


---

## Pruebas

Niveles:

- Unitarias: un solo componente, después de que es liberado por el programador
- De integración: varios componentes, después de las unitarias
- Del sistema: el sistema completo, incluye pruebas de seguridad, desempeño y documentación
- De aceptación: con el usuario, alfa (datos de prueba) y beta (datos reales)

Tipos:

- Funcionalidad: revisión de requisitos
- Seguridad: de datos, privilegios y de acceso al sistema
- Volumen: muchos datos
- Usabilidad: facilidad de uso del sistema por el usuario
- Stress: cargas de trabajo extremas o condiciones desfavorables para el sistema

---

## Liberación y Mantenimiento

- Licenciamiento

- Cierre del proyecto

- Entrega de manuales

   - M. Técnico
   
   - M. de usuario
   
   - M. mantenimiento

---

class: inverse, center, middle

# SOFTWARE CIENTIFICO

---

# Software Científico

Generalmente, en un proyecto para el análisis de datos biológicos incluye todo un **pipeline** o flujo de ejecución de varios programas que hacen "algo" y producen más datos durante el proceso de análisis. Muchas de las tareas incluyen el **formateo de datos** para pasar el resultado de un programa como entrada de datos a otro. Y en algunas ocasiones requeriremos desarrollar **scripts** en **unix** o **programas** en algún **lenguaje de programación** que nos permitan o bien formatear datos o realizar algún cálculo o análisis.

Sea que tengamos que hacer un **programa** para una tarea pequeña o bien para hacer un análisis complejo, es recomendable seguir la misma metodología para la solución de problemas. Porque permite la reproducibilidad, el reuso y el mantenimiento.

En Software científico es dificil aplicar todas las metodologías y estándares de IS, pero se recomienda aplicar algunas de ellas. Algunos esfuerzos por generar datos y software reproducibles son **los principios FAIR**.

---

## FAIR Data and Software

Los principios de **encontrabilidad, accesibilidad, interoperabilidad y reutilización** (los **principios FAIR**) se publicaron por primera vez en 2016 y se han convertido en normas ampliamente adoptadas en muchas disciplinas, con **mejores prácticas** recomendadas o exigidas para **respaldar la FAIR-calidad de los datos y del software**. 

**¿Cómo se gestionan los datos?**

* Guarde los datos brutos.
* Asegúrese de que se haga una copia de seguridad de los datos sin procesar en más de una ubicación.
* Crea los datos que deseas ver en el mundo.
* Cree datos fáciles de analizar.
* Registre todos los pasos utilizados para procesar los datos.
* Anticípese a la necesidad de utilizar varias tablas y utilice un identificador único para cada registro.
* Envíe los datos a un repositorio que emita DOI de buena reputación para que otros puedan acceder y citarlos.

---

# Tomando algunas prácticas de IS

&lt;img src="img/IS-research.png" width="600px" style="display: block; margin: auto;" /&gt;



Hay que seleccionar unas prácticas "mínimas suficientes" de ingeniería de software para abordar el desarrollo de software científico y sugeridas como línea de base.

Disponibilidad de software, Documentación de software, Control de versiones, Pruebas y soporte

---

## Disponibilidad del Software

FAIR: Accesible y Reusable

- El software utilizado en la investigación debebe estar disponible para la comunidad en repositorios abiertos con
metadatos utilizando el formato de archivo de cita estándar. 

- La entrada del repositorio del software debe estar asociada con un identificador de objeto digital (DOI). El DOI debe utilizarse en relación con cualquier publicación que utilice el software.

- El software también debe tener una licencia para que otros lo puedan volver a utilizar; por ejemplo, bajo una licencia de software de código abierto (OSS) como la licencia del Instituto Tecnológico de Massachusetts (MIT) o la licencia pública general GNU (GPL)

Ej. [Zenodo](https://zenodo.org/record/3629727/export/json#.ZAoBQhPMKKk)

---

## Documentación de Configuración, uso y expectativas del código.

- Con acceso al software, el posible replicador debe **poder ejecutar el software** de la misma manera que lo hizo el autor original.

-  Debería ser posible para una persona motivada **sin conocimiento previo del proyecto obtener una copia del código**, ejecutarlo y luego hacer un uso productivo del software, siguiendo solo los pasos incluidos en un **archivo READM**E o "introducción".

- Documentar los **requisitos de configuración del software**, incluidos los números de **versión específicos de los lenguajes de programación, paquetes, módulos u otros programas utilizados**. Si no es posible ejecutar el software en otros entornos (portabilidad), al menos debería ser posible replicar la configuración del autor.

---

## Control de Versiones

- Es fundamental para la reproducibilidad y la reutilización de la investigación que los replicadores utilicen no solo el mismo script o aplicación, sino **exactamente la misma versión del software que se utilizó** en la investigación original.

- Un sistema de control de versiones funciona como un rastreador de cambios intencionales, lo que permite a los autores registrar cambios significativos en su código como "confirmaciones" en un registro permanente. Git es muy usado en la comunidad científica.

---

## Pruebas, preferentemente unitarias

- Las pruebas **reducen el riesgo** de que los **resultados** obtenidos en la investigación **sean erróneos**, al descartar fallas debido a un comportamiento incorrecto del software.

- Sugerimos pequeñas pruebas de componentes aislados, llamadas **pruebas unitarias**, que brindan una buena retroalimentación sobre lo que salió mal cuando se informa una falla en la prueba y motivan la descomposición de códigos en pequeñosmódulos y procedimientos que facilitan compartir y reutilizar. 

- Las pruebas deben considerarse **parte de la documentación del software**, ya que encapsulan información sobre el comportamiento esperado del software. Las pruebas deben ser parte de la distribución de software estándar, junto con la documentación de cómo ejecutar las pruebas

Algunos incluyen un documento adicional de pruebas o dentro del encabezado del código se ponen ejemplos de prueba.

---

##  Soporte o mantenimiento del software

Dejar en claro en el momento de la publicación las expectativas que otros investigadores pueden tener con respecto a la **sostenibilidad del software**, tanto en términos del flujo de trabajo esperado como de los recursos disponibles, simplificará el trabajo de los autores y el de las personas que deseen ampliar ese trabajo.

Se puede incentivar una comunidad que apoye el mantenimiento del software.

---

## Codificación

Aprender a programar es relativamente sencillo, en internet encontrarás cientos de tutoriales.Pero lo realmente complicado y que se adquiere tras mucha práctica, es programar de forma estructurada, precisa y rigurosa, digase software de calidad.

* Dividir los desarrollos en fases o entregables.
--

* Coloque un breve comentario explicativo al comienzo de cada programa.
--

* Descomponer programas en funciones.
--

* Sea implacable en la eliminación de la duplicación. (DRY: don´t repear yourself)
--

* Busque siempre bibliotecas de software bien mantenidas que hagan lo que necesita.
--

* Pruebe las bibliotecas antes de confiar en ellas.
--

* Asigne nombres significativos a las funciones y variables.
--

* Haga explícitas las dependencias y los requisitos.
--

* No comente ni descomente secciones de código para controlar el comportamiento de un programa.
--

* Proporcione un ejemplo simple o un conjunto de datos de prueba.
--

* Envíe el código a un repositorio que emita DOI de buena reputación.
--

* Estandarizar las reglas del desarrollo (snakecase, camelCase) [PEP8](https://legacy.python.org/dev/peps/pep-0008/)
--

* Código explícito, Simple, No demasiado anidado.
--

* Comente tu código. Redacta sentencias simples.

---

# Encabezado

.tiny[
```{}

NAME
       ramdom-motif

VERSION
        1.0

AUTHOR
        Matthieu Defrance &lt;matthieu.dc.defrance@ulb.ac.be&gt;

DESCRIPTION
        random motif generator

CATEGORY
        motifs

USAGE
        ramdom motif [OPTIONS] 

ARGUMENTS
    --version             show program's version number and exit
    -h, --help            show this help message and exit
    -v #, --verbosity=#   set verbosity to level #
                              0 no verbosity
                              1 max verbosity
    -o #, --output=#      output results to #
                          if not specified, the standard output is used
    
SEE ALSO
        random-sites
        implant-sites

```

]

---

# Algoritmo, en el código como primera versión.

```
.....

ARGUMENTS
    --version             show program's version number and exit
    -h, --help            show this help message and exit
    -v #, --verbosity=#   set verbosity to level #
                              0 no verbosity
                              1 max verbosity
    -o #, --output=#      output results to #
                          if not specified, the standard output is used
    -i #, --input=#       input file

'''

## 1. Leer argumentos

## 2. Leer archivo de datos

## 3. Calcular suma

## 4. Imprimir resultados


```

---

# Práctica

1. Ir a https://github.com/rsa-tools/rsat-code

2. Checa como esta organizada la carpeta.

3.  Analiza el programa [infer-operon](https://github.com/rsa-tools/rsat-code/blob/master/perl-scripts/infer-operons) e indica que buenas practicas aplica. 

4. Analiza el programa [random-motif](https://github.com/rsa-tools/rsat-code/blob/master/python-scripts/random-motif) e indica que buenas practicas aplica.

5.  Analiza el programa [local-word-analysis](https://github.com/rsa-tools/rsat-code/blob/master/python-scripts/local-word-analysis) e indica que buenas practicas aplica.


---

### Bibliografía

.tiny[
1. Imelda Avalos Flores. (2010). I. Introducción a la programación. Junio 14, 2017, de Universidad Autónoma de Nayarit Sitio web: http://correo.uan.edu.mx/~iavalos/FP/FP1.html

2. SENA. (2017). Etapas del ciclo de vida. Junio 14, 2017, de wikispaces Sitio web: https://ciclodevidasoftware.wikispaces.com/ETAPAS+DEL+CICLO+DE+VIDA

3. Bernal, L. A.. (Agosto 11, 2014). Cómo hacer una prueba de escritorio. Junio 10, 2017, de aztlek.org Sitio web: https://aztlek.org/2014/08/11/como-hacer-una-prueba-de-escritorio/

4. https://islascruz.org/blog/2018/07/25/buenas-practicas-en-python/

5. https://www.educ.ar/recursos/132522/consejos-y-buenas-practicas-para-programar-en-python

6. https://www.tithink.com/es/2018/06/13/12-buenas-practicas-para-el-desarrollo-software/

7. https://wiki.python.org/moin/PythonTestingToolsTaxonomy

8. ¿Por qué es importante la Ingeniería de Software? https://medium.com/@FunktionellMx/por-qu%C3%A9-es-importante-la-ingenier%C3%ADa-de-software-a4000134f6e2

9. Metodologías de desarrollo de software: ¿qué son? 
https://blog.becas-santander.com/es/metodologias-desarrollo-software.html

10. Good enough practices in scientific computing. https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005510

11. Para generar referencias automáticamente: http://www.cva.itesm.mx/biblioteca/pagina_con_formato_version_oct/apaweb.html

]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(img/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
