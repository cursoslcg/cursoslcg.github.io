<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Secuencias <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:dodgerblue;overflow:visible;position:relative;"><path d="M416 0c17.7 0 32 14.3 32 32c0 59.8-30.3 107.5-69.4 146.6c-28 28-62.5 53.5-97.3 77.4l-2.5 1.7c-11.9 8.1-23.8 16.1-35.5 23.9l0 0 0 0 0 0-1.6 1c-6 4-11.9 7.9-17.8 11.9c-20.9 14-40.8 27.7-59.3 41.5H283.3c-9.8-7.4-20.1-14.7-30.7-22.1l7-4.7 3-2c15.1-10.1 30.9-20.6 46.7-31.6c25 18.1 48.9 37.3 69.4 57.7C417.7 372.5 448 420.2 448 480c0 17.7-14.3 32-32 32s-32-14.3-32-32H64c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-59.8 30.3-107.5 69.4-146.6c28-28 62.5-53.5 97.3-77.4c-34.8-23.9-69.3-49.3-97.3-77.4C30.3 139.5 0 91.8 0 32C0 14.3 14.3 0 32 0S64 14.3 64 32H384c0-17.7 14.3-32 32-32zM338.6 384H109.4c-10.1 10.6-18.6 21.3-25.5 32H364.1c-6.8-10.7-15.3-21.4-25.5-32zM109.4 128H338.6c10.1-10.7 18.6-21.3 25.5-32H83.9c6.8 10.7 15.3 21.3 25.5 32zm55.4 48c18.4 13.8 38.4 27.5 59.3 41.5c20.9-14 40.8-27.7 59.3-41.5H164.7z"/></svg> y formatos <svg aria-hidden="true" role="img" viewBox="0 0 384 512" style="height:1em;width:0.75em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:lemonChiffon ;overflow:visible;position:relative;"><path d="M365.3 93.38l-74.63-74.64C278.6 6.742 262.3 0 245.4 0L64-.0001c-35.35 0-64 28.65-64 64l.0065 384c0 35.34 28.65 64 64 64H320c35.2 0 64-28.8 64-64V138.6C384 121.7 377.3 105.4 365.3 93.38zM336 448c0 8.836-7.164 16-16 16H64.02c-8.838 0-16-7.164-16-16L48 64.13c0-8.836 7.164-16 16-16h160L224 128c0 17.67 14.33 32 32 32h79.1V448zM96 280C96 293.3 106.8 304 120 304h144C277.3 304 288 293.3 288 280S277.3 256 264 256h-144C106.8 256 96 266.8 96 280zM264 352h-144C106.8 352 96 362.8 96 376s10.75 24 24 24h144c13.25 0 24-10.75 24-24S277.3 352 264 352z"/></svg></title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Secuencias <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:dodgerblue;overflow:visible;position:relative;"><path d="M416 0c17.7 0 32 14.3 32 32c0 59.8-30.3 107.5-69.4 146.6c-28 28-62.5 53.5-97.3 77.4l-2.5 1.7c-11.9 8.1-23.8 16.1-35.5 23.9l0 0 0 0 0 0-1.6 1c-6 4-11.9 7.9-17.8 11.9c-20.9 14-40.8 27.7-59.3 41.5H283.3c-9.8-7.4-20.1-14.7-30.7-22.1l7-4.7 3-2c15.1-10.1 30.9-20.6 46.7-31.6c25 18.1 48.9 37.3 69.4 57.7C417.7 372.5 448 420.2 448 480c0 17.7-14.3 32-32 32s-32-14.3-32-32H64c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-59.8 30.3-107.5 69.4-146.6c28-28 62.5-53.5 97.3-77.4c-34.8-23.9-69.3-49.3-97.3-77.4C30.3 139.5 0 91.8 0 32C0 14.3 14.3 0 32 0S64 14.3 64 32H384c0-17.7 14.3-32 32-32zM338.6 384H109.4c-10.1 10.6-18.6 21.3-25.5 32H364.1c-6.8-10.7-15.3-21.4-25.5-32zM109.4 128H338.6c10.1-10.7 18.6-21.3 25.5-32H83.9c6.8 10.7 15.3 21.3 25.5 32zm55.4 48c18.4 13.8 38.4 27.5 59.3 41.5c20.9-14 40.8-27.7 59.3-41.5H164.7z"/></svg> y formatos <svg aria-hidden="true" role="img" viewBox="0 0 384 512" style="height:1em;width:0.75em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:lemonChiffon ;overflow:visible;position:relative;"><path d="M365.3 93.38l-74.63-74.64C278.6 6.742 262.3 0 245.4 0L64-.0001c-35.35 0-64 28.65-64 64l.0065 384c0 35.34 28.65 64 64 64H320c35.2 0 64-28.8 64-64V138.6C384 121.7 377.3 105.4 365.3 93.38zM336 448c0 8.836-7.164 16-16 16H64.02c-8.838 0-16-7.164-16-16L48 64.13c0-8.836 7.164-16 16-16h160L224 128c0 17.67 14.33 32 32 32h79.1V448zM96 280C96 293.3 106.8 304 120 304h144C277.3 304 288 293.3 288 280S277.3 256 264 256h-144C106.8 256 96 266.8 96 280zM264 352h-144C106.8 352 96 362.8 96 376s10.75 24 24 24h144c13.25 0 24-10.75 24-24S277.3 352 264 352z"/></svg>
]
.institute[
### Licenciatura en Ciencias Genómicas,UNAM
]
.date[
### First version: 2021-08-15; Last update: 2023-08-07
]

---





&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;


# Secuencias

## Contenido de la unidad


  1. [Bio.Seq](Clase_2_pt1_v2.0.html#5)

  2. [Archivos FASTA](Clase_2_pt1_v2.0.html#23)
  
  3. [SeqRecord](Clase_2_pt1_v2.0.html#24)

  4. [Archivos FASTQ](Clase_2_pt1_v2.0.html#37)

---

## Objetivo

- Conocer y aprender a utilizar las estructuras de datos de Biopython para manejo de secuencias de DNA, RNA y proteínas

- Conocer los tipos de formatos para manejo de secuencias biológicas de Biopython

&lt;img src="imgs/clase_2/pusheen.jpg" width="450px" style="display: block; margin: auto;" /&gt;

---

## Introducción


Con el advenimiento de las tecnologías de secuenciación masiva y la demanda por procesar cada vez más datos, surgen junto con la comunidad bioinformática nuevas herramientas para manejar los datos.

Las herramientas para poder ejecutarse necesitan **archivos de datos**, y ellas mismas generan nueva información. Estos **archivos de entrada y salida** leen un **formato específico de datos**, y muchas veces si la herramienta se vuelve muy usada, el formato de los datos se vuelve un estándar. Por eso, una parte importante de la Bioinformática es **conocer y saber usar esos formatos** para poder conectar las distintas herramientas de análisis.

Uno de los **datos** más comunes en genómica es **la secuencia**, las propiedades entorno a ella como su posición en el genóma, su strand y las distintas funcionalidades que se pueden aplicar a una secuencia como su tamaño, su contenido de AT. Además, los repositorios donde son colocadas esas secuencias y su acceso a ellas es esencial.

---

## Biopython

El Proyecto **Biopython** es una asociación internacional de **desarrolladores de Python** disponible gratuitamente (https://www.python.org) de herramientas para biología molecular computacional. 

Básicamente, el objetivo de Biopython es **facilitar al máximo el uso de Python para bioinformática** mediante la creación de **módulos y clases** reutilizables. 

Las características de Biopython incluyen analizadores para varios **formatos** de archivo de bioinformática (BLAST, ClustalW, FASTA, Genbank, ...), acceso a **servicios online** (NCBI, Expasy, ...), interfaces a common y programas no tan comunes (Clustalw, DSSP, MSMS ...), una clase de secuencia estándar, varios agrupamientos módulos, una estructura de datos de árbol KD, etc. e incluso documentación.

[source: http://biopython.org/DIST/docs/tutorial/Tutorial.pdf]

---
## Manejo de secuencias

Las **secuencias biológicas** son posiblemente el **objeto central de la bioinformática**, y en esta sección presentaremos el mecanismo de Biopython para tratar con secuencias, el objeto **Seq**. Mas adelante veremos como el Objeto SeqRecord, combina la información de secuencia con cualquier anotación.

Las secuencias son esencialmente cadenas de letras como AGTACACTGGT. Es la forma más común para representar las secuencias y se formatean en distintos formatos de archivos biológicos. 

&lt;img src="imgs/clase_2/sequenceFormats.png" width="700px" style="display: block; margin: auto;" /&gt;

---
## Secuencias .. string vs objeto Seq

Las dos diferencias más importante entre los **objetos Seq** y las **cadenas estándar** de Python son:

- que tienen diferentes métodos  
- el objeto Seq tiene el attributo alphabet.  

&lt;img src="https://www.researchgate.net/publication/328011342/figure/fig1/AS:962451910717440@1606477825497/Biotites-internal-representation-of-sequences-A-Sequence-object-takes-symbols-as-input.png" width="250px" style="display: block; margin: auto;" /&gt;
.tiny[A Sequence object takes symbols as input parameter. Each symbol is encoded into its symbol code, using a Sequence class specific alphabet. The resulting code is then stored as NumPyndarray in the Sequence object.]

Aunque el objeto Seq admite muchos de los mismos métodos que una cadena simple, su método **translate()** difiere al realizar la traducción biológica a diferencia que en un string dicho método reemplaza un caracter por otro. También hay métodos adicionales biológicamente relevantes como **reverse_complement()** en el objeto Seq.

[Métodos string](https://www.w3schools.com/python/python_ref_string.asp), 
[Métodos Bio.Seq](https://biopython.org/docs/1.75/api/Bio.Seq.html)

---

## De string a Seq

.full-width[.content-box-red[Función `Seq`: toma secuencia DNA|RNA|AA (string) y convierte a objeto `Seq`]]


```python
import Bio.Seq
*seqobj = Bio.Seq.Seq('ATGCGATCGAGC')
seqobj
```

```
## Seq('ATGCGATCGAGC')
```

.small[se puede regresar a tipo string]

```python
seq_str = str(seqobj)  # convertir con str()
print('{} tiene {} nucleotidos'.format( seq_str , len(seq_str)))
```

```
## ATGCGATCGAGC tiene 12 nucleotidos
```

---

### Abreviemos  

Para no tener que escribir todo el tiempo `Bio.Seq.Seq` podemos hacer:


```python
*from Bio.Seq import Seq
seqobj = Seq('ATGCGATCGAGC')
```

&lt;br&gt;&lt;br&gt;

.full-width[.content-box-red[Superclase `Bio`, clase `Bio.Seq` y `Seq` como subclase de `Bio` ]]

---
## Inmutabilidad

.full-width[.content-box-red[Los objetos `Seq` son inmutables. **Inmutables**: no permiten ser modificados una vez creados.]]


```python
## ERROR!!!
seqobj[0]="T"
```

Podríamos usar la funcion `.MutableSeq()` para convertir a objeto mutable

```python
from Bio.Seq import MutableSeq
# objeto mut_seq será mutable!
mut_seq = MutableSeq(seqobj)
mut_seq[0] = "T" 
```
O desde un inicio hacer nuestro objeto `MutableSeq` .tiny[(import `MutableSeq`)]


```python
from Bio.Seq import MutableSeq
```

---

&lt;img src="imgs/clase_2/meowtation.jpeg" width="450px" style="display: block; margin: auto;" /&gt;

---
## String: reverse/complement



```python
seq_str
```

```
## 'ATGCGATCGAGC'
```

¿cómo sacamos el reverso?
--


```python
#invertir secuencia 
seq_str = seq_str[::-1]
```

ahora el complemento
--


```python
#remplazar cada nucleotido por su complementario
seq_str = seq_str.replace("A", "t") 
seq_str = seq_str.replace("C", "g")
seq_str = seq_str.replace("G", "c")
seq_str = seq_str.replace("T", "a")
seq_str
```

```
## 'gctcgatcgcat'
```

---
## Objeto `Seq()`: reverse/complement

- Secuencia complementaria:

```python
*seqobj.complement()
```

```
## Seq('TACGCTAGCTCG')
```

--

- Secuencia reverso complementaria:

```python
*seqobj.reverse_complement()
```

```
## Seq('GCTCGATCGCAT')
```

--

- o su traducción .tiny[ (empieza a traducir desde inicio sin importar el codón de inicio) ]:

```python
#to_stop para en codón de paro, de lo contrario continua y escribe "*"
*seqobj.translate(to_stop = True)
```

```
## Seq('MRSS')
```

---

### Más funciones 

- Obtener transcrito

```python
*rna = seqobj.transcribe()
rna
```

```
## Seq('AUGCGAUCGAGC')
```

- y retrotranscripto

```python
*rna.back_transcribe()
```

```
## Seq('ATGCGATCGAGC')
```

---

## Objeto `Seq()`: Extraer subsecuencias

Extraer el primer codón [0:3]

```python
seqobj = Seq('ATGCGATCGAGC')
seqobj[0:3]
```

```
## Seq('ATG')
```

Podríamos usar expresiones regulares para obtener cada codón, con el módulo `re`

```python
import re
for codon in re.findall(r"(.{3})", str(seqobj)):
    print(codon)
```

```
## ATG
## CGA
## TCG
## AGC
```

---
## Buscar patrones

Buscaremos el patrón **ACG**


```python
# from Bio.Seq import Seq
*from Bio import SeqUtils

# Patrón a buscar
pattern = Seq("ACG")

# Secuencia donde buscaremos patrón
sequence = Seq("ATGCGCGACGGCGTGATCAGCTTATAGCCGTACGACTGCTGC")

# Busqueda patrón en secuencia tipo STRING!!
*results = SeqUtils.nt_search(str(sequence), pattern)

print(results)  # patrón y posiciones 
```

```
## ['ACG', 7, 31]
```

---

###  Buscar patrón reverso complementario 

Usando los métodos de `Seq`, buscar el reverso complementario del patrón en la misma secuencia:

--


```python
# reverse_complement()
results_rc = SeqUtils.nt_search(str(sequence),
*                               pattern.reverse_complement())
print(results_rc)
```

```
## ['CGT', 11, 28]
```

---

#### Contenido de GC


```python
*from Bio.SeqUtils import GC
GC(seqobj)  
GC('AGCGTGCA')
```

#### calcular masa molecular

```python
*from Bio.SeqUtils import molecular_weight
molecular_weight(seqobj)
```

#### Contar nt

```python
print(seqobj.count("ATG")) 
print(seqobj.find("GC"))  # nos da la primera posición que encuentra 
# (-1 si no encuentra)
```

.full-width[.content-box-red[ No sobrelapa, por lo que en "AAAA" dará 2 para "AA" ]]

---

# &lt;span style="color:Plum"&gt;Ejercicio 1&lt;/span&gt;

#### &lt;span style="color:Orchid"&gt;Obtener cadena protéica de cualquiera de sus ORFs&lt;/span&gt;


- .small[(Un ORF inicia con un codón inicial y termina, ya sea con un codón final o al final de la cádena.)]

&lt;br&gt;

Input a utilizar: 
&lt;pre&gt;AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGT
CTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG&lt;/pre&gt;

--

## &lt;span style="color:Plum"&gt;Ejercicio avanzado&lt;/span&gt;

#### &lt;span style="color:Orchid"&gt;Elegir la cadena protéica de mayor longitud&lt;/span&gt;

- .small[No olvidar probar todos los ORFs]

---
### RESUMEN     

- **`Bio.Seq`**

--


```python
from Bio.Seq import Seq, MutableSeq
Seq("ATGC")  # Crear objeto Seq
MutableSeq("ATGC") # Crea objeto Seq mutable
objeto.complement() # secuencia complementaria
objeto.reverse_complement()	# secuencia reverso complementaria
objeto.translate()	# secuencia traducida
objeto.transcrite() # transcrito de secuencia
objeto.back_transcribe() # retrotranscripto de secuencia 
```

- **`SeqUtils`**
--


```python
from Bio.SeqUtils import nt_search, GC, molecular_weight

nt_search("ATGC", patron) #buscar patron
GC("ATGC") # contenido GC
molecular_weight("ATGC") # peso molecular
```
---

## Secuencia consenso

&lt;img src="imgs/clase_2/consensus.jpg" width="350px" style="display: block; margin: auto;" /&gt;

&lt;br&gt;

```python
from Bio import SeqUtils

consensus = "RGWYV"
sequence = "CGTAGCTAGCTCAGAGCAGGGACACGTGCTAGCAACAGCGCT"
SeqUtils.nt_search(sequence,consensus)
## ['[AG]G[AT][CT][ACG]', 19]
```

---

## Motifs

Supongamos que tenemos las instancias de un *DNA motif*

```python
from Bio.Seq import Seq

instances = [Seq("TACAA"),
            Seq("TACGC"),
            Seq("TACAC"),
            Seq("TACCC"),
            Seq("AACCC"),
            Seq("AATGC"),
            Seq("AATGC"),
           ]
```
Podemos crear un motif .tiny[(recuerda importar `Bio.motifs`)]

.full-width[.content-box-yellow[ m = motifs.create(instances) ]]


---

## Formato fastA

&lt;br&gt;
Formato con encabezados que siempre inician con **'&gt;'**, salto de linea, seguido de secuencia de DNA, RNA o aminoácidos

&lt;br&gt;&lt;br&gt;
&lt;img src="imgs/clase_2/fasta.jpg" width="600px" style="display: block; margin: auto;" /&gt;
---
### Objetos `SeqRecord`

 `Seq` contiene la secuencia y el alfabeto
 
 Pero las secuencias generalmente vienen con más información
 
  `SeqRecord` =  `Seq` + metadata
  
atributos principales:
- **ID**: identificador (cadena) `objeto.id`
- **Seq**: secuencia (objeto Seq o similar) `objeto.seq`

Atributos adicionales:
- **name**: Nombre de la secuencia, e.g. nombre del gen (string)
- **description**: Texto adicional (cadena)
- **dbxrefs**: Lista de referencias cruzadas de bases de datos (lista de cadenas)
- **features**: Cualquier (sub)features definidos (lista de objetos SeqFeature)
- **annotations**: Más información sobre la secuencia (dictionary). cadenas, o lista de cadenas.

---
### `SeqIO`

**Standard Sequence Input/Output interface for Biopython**

**`SeqIO.parse()`**: toma archivo (o handle) y su respectivo formato para regresa iterador de `SeqRecord` .small[[Aquí puedes checar formatos](https://biopython.org/wiki/SeqIO)]


```python
from Bio import SeqIO
# parsea archivo example.fasta, puedes obtener id, seq, name, features, etc..
for record in SeqIO.parse("ejemplo.fasta", "fasta"):
    print(record.id)

# alternativamente se puede usar lo siguiente    
with open("ejemplo.fasta") as handle:
    for record in SeqIO.parse(handle, "fasta"):
        print(record.id)
```

**`SeqIO.read()`**: similar pero solo si tienes un único record en archivo


```python
*record = SeqIO.read("single.fasta", "fasta")
```

---
### Output `SeqIO`

`SeqIO.write()`: necesita `SeqRecord`, archivo output y tipo de formato


```python
secuencias = ...  
# primera forma de escribir archivo 
with open("ejemplo.fasta", "w") as output_handle:
*   SeqIO.write(secuencias, output_handle, "fasta")

# segunda forma de escribir archivo
SeqIO.write(sequences, "ejemplo.fasta", "fasta")
```

---

## Leer archivo FASTA


```python
*from Bio import SeqIO
#dirección de archivo
filename = "files/clase_2/seq.nt.fa"
#por cada record queremos ID, longitud seq y traducción
for seq_record in SeqIO.parse(filename, "fasta"):
    print('ID {}'.format(seq_record.id))
    print('len {}'.format(len(seq_record)))
    print('Traducción {}'.format(seq_record.seq.translate(to_stop=False)))
    
#  (to_stop=False,cds=True)
#cds revisa que tenga un codón de inicio
```
Secuencia es de tipo `Seq` por lo que podemos utilizar lo que vimos en [`Bio.Seq`](PythonII_L2_v0.0.html#5):

```python
seq_record.seq.complement()
seq_record.seq.reverse_complement()
rna = seq_record.seq.transcribe()
rna.back_transcribe()
```

---

## Archivo fasta a diccionario de Python

Usaremos `SeqIO.to_dict` para que nuestro archivo parseado sea convertido en un diccionario. Nota: no será conveniente si nuestro archivo es muy grande


```python
*id_dict = SeqIO.to_dict(SeqIO.parse('archivos_trabajo/seq.nt.fa', 'fasta'))
id_dict  # 'seq1' : SeqRecord(id, name, ...), ...
```
Y así accedemos:

```python
print(id_dict['seq4'], '\n')  # objeto record
print(id_dict['seq4'].seq, '\n')  # solo secuencia

print(type(id_dict['seq4'].seq), '\n')  #clase Seq

print(str(id_dict['seq4'].seq.transcribe()), '\n') 
```

---
# &lt;span style="color:Plum"&gt;Ejercicio 2&lt;/span&gt;

#### &lt;span style="color:Orchid"&gt; Imprimir codones (separados por un espacio) de cada secuencia en formato FASTA. [ARCHIVO](files/clase_2/seq.nt.fa) &lt;/span&gt;

.small[
- Crea diccionario de tu archivo FASTA

- Encuentra todos los codones del primer marco de lectura

- Imprimir los codones separados con formato FASTA
]

&lt;br&gt;

--
## &lt;span style="color:Plum"&gt;Ejercicio avanzado&lt;/span&gt;

#### &lt;span style="color:Orchid"&gt;Hacer lo mismo para los 6 marcos de lectura&lt;/span&gt;

- .small[En los encabezados deberá decir a qué marco de lectura pertenece]

---

## Manejo de FASTA con listas


```python
from Bio import SeqIO
*id_list = list(SeqIO.parse("files/clase_2/seq.nt.fa", "fasta"))
print(id_list[-1].id, '\n')  # id del ultimo elemento
```

```
## seq4
```

```python
print(id_list[-1].seq, '\n')  # seq del ultimo elemento
```

```
## ATGCTAACCAAAGTTTCAGTTCGGACGTGTCGATGAGCGACGCTCAAAAAGGAAACAACATGCCAAATAGAAACGATCAATTCGGCGATGGAAATCAGAACAACGATCAGTTTGGAAATCAAAATAGAAATAACGGGAACGATCAGTTTAATAACATGATGCAGAATAAAGGGAATAATCAATTTAATCCAGGTAATCAGAACAGAGGT
```

```python
id_list  # para examinar
```

```
## [SeqRecord(seq=Seq('AAGAGCAGCTCGCGCTAATGTGATAGATGGCGGTAAAGTAAATGTCCTATGGGC...AAC'), id='seq1', name='seq1', description='seq1', dbxrefs=[]), SeqRecord(seq=Seq('GCCACAGAGCCTAGGACCCCAACCTAACCTAACCTAACCTAACCTACAGTTTGA...TCT'), id='seq2', name='seq2', description='seq2', dbxrefs=[]), SeqRecord(seq=Seq('ATGAAAGTTACATAAAGACTATTCGATGCATAAATAGTTCAGTTTTGAAAACTT...AAT'), id='seq3', name='seq3', description='seq3', dbxrefs=[]), SeqRecord(seq=Seq('ATGCTAACCAAAGTTTCAGTTCGGACGTGTCGATGAGCGACGCTCAAAAAGGAA...GGT'), id='seq4', name='seq4', description='seq4', dbxrefs=[])]
```


---

## Archivos grandes

Usando `SeqIO.index` que solo guarda info para que mas tarde puedas acceder a ella

```python
*record_dict = SeqIO.index("example2.fasta", "fasta")

# hasta este momento recuperará la info de seq1
print(record_dict["seq1"])
```

---
#subset 

Si quisieramos hacer un fasta con ciertas secuencias podriamos hacer lo siguiente

```python
# guardamos ids de interés
seq_ids=['seq4','seq1']
```
Y ahora escribimos archivo `filtered.fasta` con seq1 y seq4

```python
with open("files/clase_2/filtered.fasta", "w") as out_handle:
    for record in SeqIO.parse('archivos_trabajo/seq.nt.fa', "fasta"):
*       if record.id in seq_ids:
            SeqIO.write(record, out_handle, "fasta")
```

---
## RNA-seq

&lt;iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Sf2Q203nHMw?start=2" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

---
### Tecnologías 

&lt;img src="imgs/clase_2/rnaseq.jpeg" width="450px" style="display: block; margin: auto;" /&gt;
&lt;img src="imgs/clase_2/rnaseq2.jpeg" width="600px" style="display: block; margin: auto;" /&gt;
.right[https://www.nature.com/articles/s41576-019-0150-2]
---

&lt;br&gt;&lt;br&gt;
&lt;img src="imgs/clase_2/rnaseq3.jpeg" width="700px" style="display: block; margin: auto;" /&gt;

&lt;br&gt;
.right[https://www.nature.com/articles/s41576-019-0150-2]
---
## Fastq

- Identificador de secuencia con información sobre la secuenciación. .tiny[Los contenidos de esta línea varian, basados en el software de conversión BCL a FASTQ usado]

- La secuencia ( A, C, T, G y N)

- Un separador, signo de más (+)

- **Puntuaciones de calidad.** Estas son codificadas con Phred +33, usando caracteres ASCII para representar puntuaciones de calidad numéricas

&lt;br&gt;
&lt;img src="imgs/clase_2/fastq.jpg" width="600px" style="display: block; margin: auto;" /&gt;

---

### ¿Qué significa el identificador?

&lt;br&gt;&lt;br&gt;
&lt;img src="imgs/clase_2/fastq_2.jpeg" width="400px" style="display: block; margin: auto;" /&gt;

---

### Score de calidad

Q score of 3 means P=0.5, meaning that there is a 50% chance the base is wrong

&lt;img src="imgs/clase_2/fastq_3.jpeg" width="200px" style="display: block; margin: auto;" /&gt;

&lt;img src="imgs/clase_2/score.png" width="550px" style="display: block; margin: auto;" /&gt;

---
## Leer archivos Fastq


```python
# from Bio import SeqIO
n = 0
# indicamos que es un archivo fastq
*for record in SeqIO.parse("archivos_trabajo/sample.fastq", "fastq"):
    if n &lt; 5:
        # pedimos id y seq
        print("%s %s" % (record.id, record.seq))
        n +=1
    else:break
        
print ('\n',record.letter_annotations.keys())

# nos da los valores en qscore (ya no en ASCII)
*print (record.letter_annotations["phred_quality"])
```

---
### FASTQC

.small[https://www.bioinformatics.babraham.ac.uk/projects/fastqc/]

Control de calidad de lecturas, contenido GC, oligos, bases N, sobrerepresentación de secuencias, etc.

**Nos puede ayudar con:** sesgo de ciertas secuencias, secuencias poco confiables, posible contaminación, evitar análisis e interpretaciones incorrectas!

&lt;img src="imgs/clase_2/fastqc.jpeg" width="550px" style="display: block; margin: auto;" /&gt;

---
### Workflow 
&lt;br&gt;
&lt;img src="imgs/clase_2/rnaseq4.jpeg" width="600px" style="display: block; margin: auto;" /&gt;

---
# &lt;span style="color:Plum"&gt;Ejercicio 3&lt;/span&gt;

#### &lt;span style="color:Orchid"&gt;Obtener número de lecturas cuyo promedio de calidad está debajo de un umbral dado [ARCHIVO](files/clase_2/sample.fastq)&lt;/span&gt;
.pull-left[
Input:
&lt;pre&gt;

@Rosalind_0041
GGCCGGTCTATTTACGTTCTCACCCGACGTGACGTACGGTCC
+
6.3536354;.151&lt;211/0?::6/-2051)-*"40/.,+%)
@Rosalind_0041
TCGTATGCGTAGCACTTGGTACAGGAAGTGAACATCCAGGAT
+
AH@FGGGJ&lt;GB&lt;&lt;9:GD=D@GG9=?A@DC=;:?&gt;839/4856
@Rosalind_0041
ATTCGGTAATTGGCGTGAATCTGTTCTGACTGATAGAGACAA
+
@DJEJEA?JHJ@8?F?IA3=;8@C95=;=?;&gt;D/:;74792.

&lt;/pre&gt;
]
.pull-right[
&lt;img src="imgs/clase_2/toreto.jpeg" width="300px" style="display: block; margin: auto 0 auto auto;" /&gt;
]
---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
